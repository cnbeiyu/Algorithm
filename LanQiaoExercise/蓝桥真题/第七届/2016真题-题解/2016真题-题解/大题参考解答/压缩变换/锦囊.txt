这道题直接按照问题描述的，对于每个数向前找到这个数，并统计之间遇到的数的种类数（使用排序），复杂度为O(n2 log n)，可以得到约30%的分数。
为了高效的解决这个问题，可以建立两棵平衡树。第一棵平衡树用于存储每个数和它最后出现的位置对应的映射。第二棵平衡树将所有数最后一次出现的位置通过树建立有序序列，并通过平衡树统计一个位置右边的结点数。
当枚举到序列中的一个数x时，首先在第一棵树中查找x，看是否出现过，如果出现过就找到最后一次出现的位置p，并在第二棵树中查找位置p右边的结点数。之后，在第一棵树中更新x对应的位置为当前位置，在第二棵树中删位置p，并把当前位置加入到第二棵树中。
使用两棵平衡树后的时间复杂度为O(n log n)，可以得到100%的分数。